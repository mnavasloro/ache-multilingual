{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar state_1 = require(\"../state\");\n\nvar query_1 = require(\"../query\");\n\nvar FilterBasedAccessor_1 = require(\"./FilterBasedAccessor\");\n\nvar map = require('lodash/map');\n\nvar get = require('lodash/get');\n\nvar includes = require('lodash/includes');\n\nvar startsWith = require('lodash/startsWith');\n\nvar each = require('lodash/each');\n\nvar take = require('lodash/take');\n\nvar NestedFacetAccessor =\n/** @class */\nfunction (_super) {\n  __extends(NestedFacetAccessor, _super);\n\n  function NestedFacetAccessor(key, options) {\n    var _this = _super.call(this, key, options.id) || this;\n\n    _this.state = new state_1.LevelState();\n    _this.options = options;\n    return _this;\n  }\n\n  NestedFacetAccessor.prototype.onResetFilters = function () {\n    this.resetState();\n  };\n\n  NestedFacetAccessor.prototype.getBuckets = function (level) {\n    var buckets = this.getAggregations([this.key, 'children', 'lvl' + level, 'children', 'buckets'], []);\n    return map(buckets, function (item) {\n      item.key = String(item.key);\n      return item;\n    });\n  };\n\n  NestedFacetAccessor.prototype.buildSharedQuery = function (query) {\n    var _this = this;\n\n    var levelFilters = this.state.getValue();\n    var lastIndex = levelFilters.length - 1;\n    var filterTerms = map(levelFilters, function (filter, i) {\n      var value = filter[0];\n      var isLeaf = i === lastIndex;\n      var subField = isLeaf ? '.value' : '.ancestors';\n      return query_1.TermQuery(_this.options.field + subField, value);\n    });\n\n    if (filterTerms.length > 0) {\n      var leafFilter = get(levelFilters, [levelFilters.length - 1, 0], '');\n      var parentOfleaf = get(levelFilters, [levelFilters.length - 2, 0], this.options.title || this.key);\n      var selectedFilter = {\n        id: this.key,\n        name: this.translate(parentOfleaf),\n        value: leafFilter,\n        remove: function remove() {\n          _this.state = _this.state.clear(levelFilters.length - 1);\n        }\n      };\n      query = query.addFilter(this.uuid, query_1.NestedQuery(this.options.field, query_1.BoolMust(filterTerms))).addSelectedFilter(selectedFilter);\n    }\n\n    return query;\n  };\n\n  NestedFacetAccessor.prototype.getTermAggs = function () {\n    var _a, _b;\n\n    var subAggs = undefined;\n    var orderMetric = undefined;\n\n    if (this.options.orderKey) {\n      var orderDirection = this.options.orderDirection || 'asc';\n      var orderKey = this.options.orderKey;\n\n      if (includes(['_count', '_term'], orderKey)) {\n        orderMetric = (_a = {}, _a[orderKey] = orderDirection, _a);\n      } else {\n        if (startsWith(orderKey, this.options.field + '.')) {\n          var subAggName = this.options.field + '_order';\n          orderMetric = (_b = {}, _b[subAggName] = orderDirection, _b);\n          subAggs = query_1.MinMetric(subAggName, orderKey);\n        }\n      }\n    }\n\n    var valueField = this.options.field + '.value';\n    var nBuckets = this.options.size || query_1.DefaultNumberBuckets;\n    return query_1.TermsBucket('children', valueField, {\n      size: nBuckets,\n      order: orderMetric\n    }, subAggs);\n  };\n\n  NestedFacetAccessor.prototype.buildOwnQuery = function (query) {\n    var levelField = this.options.field + '.level';\n    var ancestorsField = this.options.field + '.ancestors';\n    var startLevel = this.options.startLevel || 1;\n    var termAggs = this.getTermAggs();\n    var lvlAggs = [];\n\n    var addLevel = function addLevel(level, ancestors) {\n      if (ancestors === void 0) {\n        ancestors = [];\n      }\n\n      lvlAggs.push(query_1.FilterBucket('lvl' + level, query_1.BoolMust(__spreadArrays([query_1.TermQuery(levelField, level + startLevel)], ancestors)), termAggs));\n    };\n\n    addLevel(0);\n    var levels = this.state.getValue();\n    each(levels, function (_level, i) {\n      var ancestors = map(take(levels, i + 1), function (level) {\n        return query_1.TermQuery(ancestorsField, level[0]);\n      });\n      addLevel(i + 1, ancestors);\n    });\n    return query.setAggs(query_1.FilterBucket(this.key, query.getFiltersWithoutKeys(this.uuid), query_1.NestedBucket.apply(void 0, __spreadArrays(['children', this.options.field], lvlAggs))));\n  };\n\n  return NestedFacetAccessor;\n}(FilterBasedAccessor_1.FilterBasedAccessor);\n\nexports.NestedFacetAccessor = NestedFacetAccessor;","map":{"version":3,"mappings":"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","names":["map","require","get","includes","startsWith","each","take","__extends","key","options","_super","id","_this","state_1","NestedFacetAccessor","resetState","level","buckets","getAggregations","item","String","query","levelFilters","state","getValue","lastIndex","length","filterTerms","filter","i","value","isLeaf","subField","query_1","field","leafFilter","parentOfleaf","title","selectedFilter","name","translate","remove","clear","addFilter","uuid","addSelectedFilter","subAggs","undefined","orderMetric","orderKey","orderDirection","_a","subAggName","_b","valueField","nBuckets","size","order","levelField","ancestorsField","startLevel","termAggs","getTermAggs","lvlAggs","addLevel","ancestors","push","__spreadArrays","levels","_level","setAggs","getFiltersWithoutKeys","apply","FilterBasedAccessor_1","exports"],"sources":["C:\\Users\\mnavas\\CODE\\SmartBIC\\ache-multilingual\\ache-dashboard\\node_modules\\searchkit\\src\\core\\accessors\\NestedFacetAccessor.ts"],"sourcesContent":["import { LevelState } from '../state'\nimport {\n  TermQuery,\n  TermsBucket,\n  FilterBucket,\n  BoolMust,\n  NestedQuery,\n  NestedBucket,\n  MinMetric,\n  DefaultNumberBuckets\n} from '../query'\nimport { FilterBasedAccessor } from './FilterBasedAccessor'\n\nconst map = require('lodash/map')\nconst get = require('lodash/get')\nconst includes = require('lodash/includes')\nconst startsWith = require('lodash/startsWith')\nconst each = require('lodash/each')\nconst take = require('lodash/take')\n\nexport interface NestedFacetAccessorOptions {\n  field: string\n  id: string\n  title: string\n  size?: number\n  orderKey?: string\n  orderDirection?: string\n  startLevel?: number\n}\n\nexport class NestedFacetAccessor extends FilterBasedAccessor<LevelState> {\n  state = new LevelState()\n  options: any\n\n  constructor(key, options: NestedFacetAccessorOptions) {\n    super(key, options.id)\n    this.options = options\n  }\n\n  onResetFilters() {\n    this.resetState()\n  }\n\n  getBuckets(level) {\n    const buckets: Array<any> = this.getAggregations(\n      [this.key, 'children', 'lvl' + level, 'children', 'buckets'],\n      []\n    )\n    return map(buckets, (item) => {\n      item.key = String(item.key)\n      return item\n    })\n  }\n\n  buildSharedQuery(query) {\n    const levelFilters = this.state.getValue()\n    const lastIndex = levelFilters.length - 1\n    const filterTerms = map(levelFilters, (filter, i) => {\n      const value = filter[0]\n      const isLeaf = i === lastIndex\n      const subField = isLeaf ? '.value' : '.ancestors'\n      return TermQuery(this.options.field + subField, value)\n    })\n\n    if (filterTerms.length > 0) {\n      const leafFilter = get(levelFilters, [levelFilters.length - 1, 0], '')\n      const parentOfleaf = get(\n        levelFilters,\n        [levelFilters.length - 2, 0],\n        this.options.title || this.key\n      )\n      const selectedFilter = {\n        id: this.key,\n        name: this.translate(parentOfleaf),\n        value: leafFilter,\n        remove: () => {\n          this.state = this.state.clear(levelFilters.length - 1)\n        }\n      }\n\n      query = query\n        .addFilter(this.uuid, NestedQuery(this.options.field, BoolMust(filterTerms)))\n        .addSelectedFilter(selectedFilter)\n    }\n    return query\n  }\n\n  getTermAggs() {\n    let subAggs = undefined\n    let orderMetric = undefined\n    if (this.options.orderKey) {\n      const orderDirection = this.options.orderDirection || 'asc'\n      const orderKey = this.options.orderKey\n      if (includes(['_count', '_term'], orderKey)) {\n        orderMetric = { [orderKey]: orderDirection }\n      } else {\n        if (startsWith(orderKey, this.options.field + '.')) {\n          const subAggName = this.options.field + '_order'\n          orderMetric = {\n            [subAggName]: orderDirection\n          }\n          subAggs = MinMetric(subAggName, orderKey)\n        }\n      }\n    }\n\n    const valueField = this.options.field + '.value'\n    const nBuckets = this.options.size || DefaultNumberBuckets\n\n    return TermsBucket('children', valueField, { size: nBuckets, order: orderMetric }, subAggs)\n  }\n\n  buildOwnQuery(query) {\n    const levelField = this.options.field + '.level'\n    const ancestorsField = this.options.field + '.ancestors'\n    const startLevel = this.options.startLevel || 1\n    const termAggs = this.getTermAggs()\n    const lvlAggs = []\n    const addLevel = (level, ancestors = []) => {\n      lvlAggs.push(\n        FilterBucket(\n          'lvl' + level,\n          BoolMust([TermQuery(levelField, level + startLevel), ...ancestors]),\n          termAggs\n        )\n      )\n    }\n\n    addLevel(0)\n\n    const levels = this.state.getValue()\n    each(levels, (_level, i) => {\n      const ancestors = map(take(levels, i + 1), (level) => TermQuery(ancestorsField, level[0]))\n\n      addLevel(i + 1, ancestors)\n    })\n\n    return query.setAggs(\n      FilterBucket(\n        this.key,\n        query.getFiltersWithoutKeys(this.uuid),\n        NestedBucket('children', this.options.field, ...lvlAggs)\n      )\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}