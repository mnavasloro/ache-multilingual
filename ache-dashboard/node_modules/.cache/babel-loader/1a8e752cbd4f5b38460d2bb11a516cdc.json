{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _SCALE_FUNCTIONS;\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\nimport PropTypes from 'prop-types';\nimport { warning } from './react-utils';\nimport { getUniquePropertyValues, addValueToArray } from './data-utils';\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\n\nvar LINEAR_SCALE_TYPE = 'linear';\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\n\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n/**\n * Category scale.\n * @type {string}\n * @const\n */\n\nvar CATEGORY_SCALE_TYPE = 'category';\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\n\nvar LITERAL_SCALE_TYPE = 'literal';\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\n\nvar LOG_SCALE_TYPE = 'log';\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_SCALE_TYPE = 'time';\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\n\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\n\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\n\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\n\n\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n\n      currentValue = nextValue;\n    }\n  }\n\n  return result;\n}\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\n\n\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n\n  return scale;\n}\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\n\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0; // Collect both attr and available attr0 values from the array of data.\n\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  } // Create proper domain depending on the type of the scale.\n\n\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n\n  return domain;\n}\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\n\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n\n  if (typeof value === 'undefined') {\n    return null;\n  }\n\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\n\n\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\n\n\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props['_' + attr + 'Value'],\n      range = props[attr + 'Range'],\n      _props$ = props[attr + 'Distance'],\n      distance = _props$ === undefined ? 0 : _props$,\n      baseValue = props[attr + 'BaseValue'],\n      _props$2 = props[attr + 'Type'],\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[attr + 'NoFallBack'],\n      _props$3 = props['get' + toTitleCase(attr)],\n      accessor = _props$3 === undefined ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\n      accessor0 = _props$4 === undefined ? function (d) {\n    return d[attr + '0'];\n  } : _props$4;\n  var domain = props[attr + 'Domain']; // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  } // Pick up the domain from the properties and create a new one if it's not\n  // available.\n\n\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  } // Make sure that the minimum necessary properties exist.\n\n\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n\n  return 0;\n}\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\n\n\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n\n  return 0;\n}\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\n\n\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\n\n\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n  var uniqueValues = getUniquePropertyValues(data, accessor); // Fix time scale if a data has only one value.\n\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values); // Fix log scale if it's too small.\n\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\n\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat; // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\n\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2; // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance; // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n  scaleObject.distance = scaleDistance;\n  return scaleObject;\n}\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\n\n\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\n\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n\n  if (!scaleObject) {\n    return null;\n  } // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n\n\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type; // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n\n  return _adjustContinuousScale(props, scaleObject);\n}\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\n\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\n\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\n\n\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\n\n\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n\n  return null;\n}\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\n\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n\n  return null;\n}\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\n\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      warning('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n\n  return null;\n}\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\n\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', PropTypes.any), _defineProperty(_ref2, attr + 'Domain', PropTypes.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), PropTypes.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', PropTypes.func), _defineProperty(_ref2, attr + 'Range', PropTypes.array), _defineProperty(_ref2, attr + 'Type', PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', PropTypes.number), _defineProperty(_ref2, attr + 'BaseValue', PropTypes.any), _ref2;\n}\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0; // Ex: _data\n\n      var isUnderscoreSet = key.indexOf('_' + a) === 0; // EX: getX\n\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n\n    if (!attr) {\n      return;\n    }\n\n    result[key] = props[key];\n  });\n  return result;\n}\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\n\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {}; // Make sure that the domain is set pad it if specified\n\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n  return result;\n}\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\n\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n  return scale;\n}\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n\n  return null;\n}\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n        range = props[attr + 'Range'],\n        type = props[attr + 'Type'];\n\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n\n    return prev;\n  }, {});\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n\n      return prev;\n    }, {});\n  });\n}\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\n\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n\n    if (propIsNotOptional) {\n      return acc;\n    }\n\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","Array","isArray","TypeError","_SCALE_FUNCTIONS","_toConsumableArray","arr2","from","_defineProperty","obj","defineProperty","enumerable","configurable","writable","scaleLinear","scalePoint","scaleOrdinal","scaleLog","scaleTime","scaleUtc","extent","set","hsl","PropTypes","warning","getUniquePropertyValues","addValueToArray","LINEAR_SCALE_TYPE","ORDINAL_SCALE_TYPE","CATEGORY_SCALE_TYPE","LITERAL_SCALE_TYPE","LOG_SCALE_TYPE","TIME_SCALE_TYPE","TIME_UTC_SCALE_TYPE","SCALE_FUNCTIONS","literalScale","XYPLOT_ATTR","toTitleCase","str","toUpperCase","slice","_getSmallestDistanceIndex","values","scaleObject","scaleFn","getScaleFnFromScaleObject","result","nextValue","currentValue","distance","Infinity","nextDistance","Math","abs","addInvertFunctionToOrdinalScaleObject","scale","invert","_scale$range","range","_scale$range2","lower","upper","start","min","stop","max","padding","step","domain","index","floor","type","modDomain","getDomainByAccessor","allData","accessor","accessor0","reduce","data","d","value0","_isDefined","_createScaleObjectForValue","attr","baseValue","isValue","_createScaleObjectForFunction","_ref","_collectScaleObjectFromProps","props","fallbackValue","_props$","_props$2","noFallBack","_props$3","_props$4","_computeLeftDomainAdjustment","_computeRightDomainAdjustment","_computeScaleDistance","bestDistIndex","_normalizeValues","attr0","concat","_getScaleDistanceAndAdjustedDomain","uniqueValues","adjustedDomain","adjustedScaleFn","domain0","domainN","_isScaleAdjustmentPossible","_props$_adjustBy","_adjustBy","adjustBy","_props$_adjustWhat","_adjustWhat","adjustWhat","indexOf","_adjustContinuousScale","allSeriesData","_allData","_props$_adjustWhat2","domainLength","scaleDomain0","scaleDomainN","scaleDistance","forEach","_getScaleDistanceAndA","_adjustCategoricalScale","getScaleObjectFromProps","getAttributeScale","_getAttrValue","_padDomain","isNaN","parseFloat","_domain","domainPadding","getAttributeFunctor","getAttr0Functor","_scaleObject$baseValu","getAttributeValue","getScalePropTypesByAttribute","_ref2","any","array","func","oneOf","keys","number","extractScalePropsFromProps","attributes","find","a","isPlainSet","isUnderscoreSet","usesGet","getMissingScaleProps","defaultValue","response","unknown","copy","getFontColorFromBackground","background","l","getXYPlotValues","children","XYPlotScales","prev","map","child","scaleInput","OPTIONAL_SCALE_PROPS","OPTIONAL_SCALE_PROPS_REGS","RegExp","getOptionalScaleProps","acc","prop","propIsNotOptional","every","reg","match"],"sources":["C:/Users/mnavas/CODE/SmartBIC/ache-multilingual/ache-dashboard/node_modules/react-vis/es/utils/scales-utils.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _SCALE_FUNCTIONS;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { scaleLinear, scalePoint, scaleOrdinal, scaleLog, scaleTime, scaleUtc } from 'd3-scale';\nimport { extent } from 'd3-array';\nimport { set } from 'd3-collection';\nimport { hsl } from 'd3-color';\n\nimport PropTypes from 'prop-types';\n\nimport { warning } from './react-utils';\nimport { getUniquePropertyValues, addValueToArray } from './data-utils';\n\n/**\n * Linear scale name.\n * @type {string}\n * @const\n */\nvar LINEAR_SCALE_TYPE = 'linear';\n\n/**\n * Ordinal scale name.\n * @type {string}\n * @const\n */\nvar ORDINAL_SCALE_TYPE = 'ordinal';\n\n/**\n * Category scale.\n * @type {string}\n * @const\n */\nvar CATEGORY_SCALE_TYPE = 'category';\n\n/**\n * Literal scale.\n * Differs slightly from d3's identity scale in that it does not coerce value\n * into numbers, it simply returns exactly what you give it\n * @type {string}\n * @const\n */\nvar LITERAL_SCALE_TYPE = 'literal';\n\n/**\n * Log scale name.\n * @type {string}\n * @const\n */\nvar LOG_SCALE_TYPE = 'log';\n\n/**\n * Time scale name.\n * @type {string}\n * @const\n */\nvar TIME_SCALE_TYPE = 'time';\n\n/**\n * Time UTC scale name.\n * @type {string}\n * @const\n */\nvar TIME_UTC_SCALE_TYPE = 'time-utc';\n\n/**\n * Scale functions that are supported in the library.\n * @type {Object}\n * @const\n */\nvar SCALE_FUNCTIONS = (_SCALE_FUNCTIONS = {}, _defineProperty(_SCALE_FUNCTIONS, LINEAR_SCALE_TYPE, scaleLinear), _defineProperty(_SCALE_FUNCTIONS, ORDINAL_SCALE_TYPE, scalePoint), _defineProperty(_SCALE_FUNCTIONS, CATEGORY_SCALE_TYPE, scaleOrdinal), _defineProperty(_SCALE_FUNCTIONS, LITERAL_SCALE_TYPE, literalScale), _defineProperty(_SCALE_FUNCTIONS, LOG_SCALE_TYPE, scaleLog), _defineProperty(_SCALE_FUNCTIONS, TIME_SCALE_TYPE, scaleTime), _defineProperty(_SCALE_FUNCTIONS, TIME_UTC_SCALE_TYPE, scaleUtc), _SCALE_FUNCTIONS);\n\n/**\n * Attrs for which a scale can be set up at XYPlot level\n * @type {Array}\n * @const\n */\n\nvar XYPLOT_ATTR = ['color', 'fill', 'opacity', 'stroke'];\n\n/**\n * Title case a given string\n * @param {String} str Array of values.\n * @returns {String} titlecased string\n */\nfunction toTitleCase(str) {\n  return '' + str[0].toUpperCase() + str.slice(1);\n}\n\n/**\n * Find the smallest distance between the values on a given scale and return\n * the index of the element, where the smallest distance was found.\n * It returns the first occurrence of i where\n * `scale(value[i]) - scale(value[i - 1])` is minimal\n * @param {Array} values Array of values.\n * @param {Object} scaleObject Scale object.\n * @returns {number} Index of an element where the smallest distance was found.\n * @private\n */\nexport function _getSmallestDistanceIndex(values, scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var result = 0;\n  if (scaleFn) {\n    var nextValue = void 0;\n    var currentValue = scaleFn(values[0]);\n    var distance = Infinity;\n    var nextDistance = void 0;\n\n    for (var i = 1; i < values.length; i++) {\n      nextValue = scaleFn(values[i]);\n      nextDistance = Math.abs(nextValue - currentValue);\n      if (nextDistance < distance) {\n        distance = nextDistance;\n        result = i;\n      }\n      currentValue = nextValue;\n    }\n  }\n  return result;\n}\n\n/**\n * This is a workaround for issue that ordinal scale\n * does not have invert method implemented in d3-scale.\n * @param {Object} Ordinal d3-scale object.\n * @returns {void}\n * @private\n */\n\nfunction addInvertFunctionToOrdinalScaleObject(scale) {\n  if (scale.invert) {\n    return;\n  }\n\n  scale.invert = function invert(value) {\n    var _scale$range = scale.range(),\n        _scale$range2 = _slicedToArray(_scale$range, 2),\n        lower = _scale$range2[0],\n        upper = _scale$range2[1];\n\n    var start = Math.min(lower, upper);\n    var stop = Math.max(lower, upper);\n\n    if (value < start + scale.padding() * scale.step()) {\n      return scale.domain()[0];\n    }\n\n    if (value > stop - scale.padding() * scale.step()) {\n      return scale.domain()[scale.domain().length - 1];\n    }\n\n    var index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());\n    return scale.domain()[index];\n  };\n}\n\n/**\n * Crate a scale function from the scale object.\n * @param {Object} scaleObject Scale object.\n - scaleObject.domain {Array}\n - scaleObject.range {Array}\n - scaleObject.type {string}\n - scaleObject.attr {string}\n * @returns {*} Scale function.\n * @private\n */\nexport function getScaleFnFromScaleObject(scaleObject) {\n  if (!scaleObject) {\n    return null;\n  }\n  var type = scaleObject.type,\n      domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  var modDomain = domain[0] === domain[1] ? domain[0] === 0 ? [-1, 0] : [-domain[0], domain[0]] : domain;\n  if (type === LITERAL_SCALE_TYPE) {\n    return literalScale(range[0]);\n  }\n  var scale = SCALE_FUNCTIONS[type]().domain(modDomain).range(range);\n  if (type === ORDINAL_SCALE_TYPE) {\n    scale.padding(0.5);\n    addInvertFunctionToOrdinalScaleObject(scale);\n  }\n  return scale;\n}\n\n/**\n * Get the domain from the array of data.\n * @param {Array} allData All data.\n * @param {function} accessor - accessor for main value.\n * @param {function} accessor0 - accessor for the naught value.\n * @param {string} type Scale type.\n * @returns {Array} Domain.\n * @private\n */\nexport function getDomainByAccessor(allData, accessor, accessor0, type) {\n  var domain = void 0;\n\n  // Collect both attr and available attr0 values from the array of data.\n  var values = allData.reduce(function (data, d) {\n    var value = accessor(d);\n    var value0 = accessor0(d);\n    if (_isDefined(value)) {\n      data.push(value);\n    }\n    if (_isDefined(value0)) {\n      data.push(value0);\n    }\n    return data;\n  }, []);\n\n  if (!values.length) {\n    return [];\n  }\n\n  // Create proper domain depending on the type of the scale.\n  if (type !== ORDINAL_SCALE_TYPE && type !== CATEGORY_SCALE_TYPE) {\n    domain = extent(values);\n  } else {\n    domain = set(values).values();\n  }\n  return domain;\n}\n\n/**\n * Create custom scale object from the value. When the scale is created from\n * this object, it should return the same value all time.\n * @param {string} attr Attribute.\n * @param {*} value Value.\n * @param {string} type - the type of scale being used\n * @param {function} accessor - the accessor function\n * @param {function} accessor0 - the accessor function for the potential naught value\n * @returns {Object} Custom scale object.\n * @private\n */\nfunction _createScaleObjectForValue(attr, value, type, accessor, accessor0) {\n  if (type === LITERAL_SCALE_TYPE) {\n    return {\n      type: LITERAL_SCALE_TYPE,\n      domain: [],\n      range: [value],\n      distance: 0,\n      attr: attr,\n      baseValue: undefined,\n      isValue: true,\n      accessor: accessor,\n      accessor0: accessor0\n    };\n  }\n  if (typeof value === 'undefined') {\n    return null;\n  }\n  return {\n    type: CATEGORY_SCALE_TYPE,\n    range: [value],\n    domain: [],\n    distance: 0,\n    attr: attr,\n    baseValue: undefined,\n    isValue: true,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Create a regular scale object for a further use from the existing parameters.\n * @param {Array} domain - Domain.\n * @param {Array} range - Range.\n * @param {string} type - Type.\n * @param {number} distance - Distance.\n * @param {string} attr - Attribute.\n * @param {number} baseValue - Base value.\n * @param {function} accessor - Attribute accesor\n * @param {function} accessor0 - Attribute accesor for potential naught value\n * @returns {Object} Scale object.\n * @private\n */\nfunction _createScaleObjectForFunction(_ref) {\n  var domain = _ref.domain,\n      range = _ref.range,\n      type = _ref.type,\n      distance = _ref.distance,\n      attr = _ref.attr,\n      baseValue = _ref.baseValue,\n      accessor = _ref.accessor,\n      accessor0 = _ref.accessor0;\n\n  return {\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    isValue: false,\n    accessor: accessor,\n    accessor0: accessor0\n  };\n}\n\n/**\n * Get scale object from props. E. g. object like {xRange, xDomain, xDistance,\n * xType} is transformed into {range, domain, distance, type}.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {*} Null or an object with the scale.\n * @private\n */\nfunction _collectScaleObjectFromProps(props, attr) {\n  var value = props[attr],\n      fallbackValue = props['_' + attr + 'Value'],\n      range = props[attr + 'Range'],\n      _props$ = props[attr + 'Distance'],\n      distance = _props$ === undefined ? 0 : _props$,\n      baseValue = props[attr + 'BaseValue'],\n      _props$2 = props[attr + 'Type'],\n      type = _props$2 === undefined ? LINEAR_SCALE_TYPE : _props$2,\n      noFallBack = props[attr + 'NoFallBack'],\n      _props$3 = props['get' + toTitleCase(attr)],\n      accessor = _props$3 === undefined ? function (d) {\n    return d[attr];\n  } : _props$3,\n      _props$4 = props['get' + toTitleCase(attr) + '0'],\n      accessor0 = _props$4 === undefined ? function (d) {\n    return d[attr + '0'];\n  } : _props$4;\n  var domain = props[attr + 'Domain'];\n  // Return value-based scale if the value is assigned.\n\n  if (!noFallBack && typeof value !== 'undefined') {\n    return _createScaleObjectForValue(attr, value, props[attr + 'Type'], accessor, accessor0);\n  }\n  // Pick up the domain from the properties and create a new one if it's not\n  // available.\n  if (typeof baseValue !== 'undefined') {\n    domain = addValueToArray(domain, baseValue);\n  }\n\n  // Make sure that the minimum necessary properties exist.\n  if (!range || !domain || !domain.length) {\n    // Try to use the fallback value if it is available.\n    return _createScaleObjectForValue(attr, fallbackValue, props[attr + 'Type'], accessor, accessor0);\n  }\n\n  return _createScaleObjectForFunction({\n    domain: domain,\n    range: range,\n    type: type,\n    distance: distance,\n    attr: attr,\n    baseValue: baseValue,\n    accessor: accessor,\n    accessor0: accessor0\n  });\n}\n\n/**\n * Compute left domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeLeftDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[1] - values[0]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute right domain adjustment for the given values.\n * @param {Array} values Array of values.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeRightDomainAdjustment(values) {\n  if (values.length > 1) {\n    return (values[values.length - 1] - values[values.length - 2]) / 2;\n  }\n  if (values.length === 1) {\n    return values[0] - 0.5;\n  }\n  return 0;\n}\n\n/**\n * Compute distance for the given values.\n * @param {Array} values Array of values.\n * @param {Array} domain Domain.\n * @param {number} bestDistIndex Index of a best distance found.\n * @param {function} scaleFn Scale function.\n * @returns {number} Domain adjustment.\n * @private\n */\nfunction _computeScaleDistance(values, domain, bestDistIndex, scaleFn) {\n  if (values.length > 1) {\n    // Avoid zero indexes.\n    var i = Math.max(bestDistIndex, 1);\n    return Math.abs(scaleFn(values[i]) - scaleFn(values[i - 1]));\n  }\n  if (values.length === 1) {\n    return Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  }\n  return 0;\n}\n\n/**\n * Normilize array of values with a single value.\n * @param {Array} arr Array of data.\n * @param {Array} values Array of values.\n * @param {string} attr Attribute.\n * @param {string} type Type.\n * @private\n */\nfunction _normalizeValues(data, values, accessor0, type) {\n  if (type === TIME_SCALE_TYPE && values.length === 1) {\n    var attr0 = accessor0(data[0]);\n\n    return [attr0].concat(_toConsumableArray(values));\n  }\n\n  return values;\n}\n\n/**\n * Get the distance, the smallest and the largest value of the domain.\n * @param {Array} data Array of data for the single series.\n * @param {Object} scaleObject Scale object.\n * @returns {{domain0: number, domainN: number, distance: number}} Result.\n * @private\n */\nexport function _getScaleDistanceAndAdjustedDomain(data, scaleObject) {\n  var domain = scaleObject.domain,\n      type = scaleObject.type,\n      accessor = scaleObject.accessor,\n      accessor0 = scaleObject.accessor0;\n\n\n  var uniqueValues = getUniquePropertyValues(data, accessor);\n\n  // Fix time scale if a data has only one value.\n  var values = _normalizeValues(data, uniqueValues, accessor0, type);\n  var index = _getSmallestDistanceIndex(values, scaleObject);\n\n  var adjustedDomain = [].concat(domain);\n\n  adjustedDomain[0] -= _computeLeftDomainAdjustment(values);\n  adjustedDomain[domain.length - 1] += _computeRightDomainAdjustment(values);\n  // Fix log scale if it's too small.\n  if (type === LOG_SCALE_TYPE && domain[0] <= 0) {\n    adjustedDomain[0] = Math.min(domain[1] / 10, 1);\n  }\n\n  var adjustedScaleFn = getScaleFnFromScaleObject(_extends({}, scaleObject, {\n    domain: adjustedDomain\n  }));\n\n  var distance = _computeScaleDistance(values, adjustedDomain, index, adjustedScaleFn);\n\n  return {\n    domain0: adjustedDomain[0],\n    domainN: adjustedDomain[adjustedDomain.length - 1],\n    distance: distance\n  };\n}\n\n/**\n * Returns true if scale adjustments are possible for a given scale.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {boolean} True if scale adjustments possible.\n * @private\n */\nfunction _isScaleAdjustmentPossible(props, scaleObject) {\n  var attr = scaleObject.attr;\n  var _props$_adjustBy = props._adjustBy,\n      adjustBy = _props$_adjustBy === undefined ? [] : _props$_adjustBy,\n      _props$_adjustWhat = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat === undefined ? [] : _props$_adjustWhat;\n\n  // The scale cannot be adjusted if there's no attributes to adjust, no\n  // suitable values\n\n  return adjustWhat.length && adjustBy.length && adjustBy.indexOf(attr) !== -1;\n}\n\n/**\n * Adjust continuous scales (e.g. 'linear', 'log' and 'time') by adding the\n * space from the left and right of them and by computing the best distance.\n * @param {Object} props Props.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nfunction _adjustContinuousScale(props, scaleObject) {\n  var allSeriesData = props._allData,\n      _props$_adjustWhat2 = props._adjustWhat,\n      adjustWhat = _props$_adjustWhat2 === undefined ? [] : _props$_adjustWhat2;\n\n  // Assign the initial values.\n\n  var domainLength = scaleObject.domain.length;\n  var domain = scaleObject.domain;\n\n  var scaleDomain0 = domain[0];\n  var scaleDomainN = domain[domainLength - 1];\n  var scaleDistance = scaleObject.distance;\n\n  // Find the smallest left position of the domain, the largest right position\n  // of the domain and the best distance for them.\n  allSeriesData.forEach(function (data, index) {\n    if (adjustWhat.indexOf(index) === -1) {\n      return;\n    }\n    if (data && data.length) {\n      var _getScaleDistanceAndA = _getScaleDistanceAndAdjustedDomain(data, scaleObject),\n          domain0 = _getScaleDistanceAndA.domain0,\n          domainN = _getScaleDistanceAndA.domainN,\n          distance = _getScaleDistanceAndA.distance;\n\n      scaleDomain0 = Math.min(scaleDomain0, domain0);\n      scaleDomainN = Math.max(scaleDomainN, domainN);\n      scaleDistance = Math.max(scaleDistance, distance);\n    }\n  });\n\n  scaleObject.domain = [scaleDomain0].concat(_toConsumableArray(domain.slice(1, -1)), [scaleDomainN]);\n\n  scaleObject.distance = scaleDistance;\n\n  return scaleObject;\n}\n\n/**\n * Get an adjusted scale. Suitable for 'category' and 'ordinal' scales.\n * @param {Object} scaleObject Scale object.\n * @returns {*} Scale object with adjustments.\n * @private\n */\nexport function _adjustCategoricalScale(scaleObject) {\n  var scaleFn = getScaleFnFromScaleObject(scaleObject);\n  var domain = scaleObject.domain,\n      range = scaleObject.range;\n\n  if (domain.length > 1) {\n    scaleObject.distance = Math.abs(scaleFn(domain[1]) - scaleFn(domain[0]));\n  } else {\n    scaleObject.distance = Math.abs(range[1] - range[0]);\n  }\n\n  return scaleObject;\n}\n\n/**\n * Retrieve a scale object or a value from the properties passed.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute.\n * @returns {*} Scale object, value or null.\n */\nexport function getScaleObjectFromProps(props, attr) {\n  // Create the initial scale object.\n  var scaleObject = _collectScaleObjectFromProps(props, attr);\n  if (!scaleObject) {\n    return null;\n  }\n\n  // Make sure if it's possible to add space to the scale object. If not,\n  // return the object immediately.\n  if (!_isScaleAdjustmentPossible(props, scaleObject)) {\n    return scaleObject;\n  }\n\n  var type = scaleObject.type;\n  // Depending on what type the scale is, apply different adjustments. Distances\n  // for the ordinal and category scales are even, equal domains cannot be\n  // adjusted.\n\n  if (type === ORDINAL_SCALE_TYPE || type === CATEGORY_SCALE_TYPE) {\n    return _adjustCategoricalScale(scaleObject);\n  }\n  return _adjustContinuousScale(props, scaleObject);\n}\n\n/**\n * Get d3 scale for a given prop.\n * @param {Object} props Props.\n * @param {string} attr Attribute.\n * @returns {function} d3 scale function.\n */\nexport function getAttributeScale(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  return getScaleFnFromScaleObject(scaleObject);\n}\n\n/**\n * Get the value of `attr` from the object.\n * @param {Object} d - data Object.\n * @param {Function} accessor - accessor function.\n * @returns {*} Value of the point.\n * @private\n */\nfunction _getAttrValue(d, accessor) {\n  return accessor(d.data ? d.data : d);\n}\n\nfunction _isDefined(value) {\n  return typeof value !== 'undefined';\n}\n\n/*\n * Adds a percentage of padding to a given domain\n * @param {Array} domain X or Y domain to pad.\n * @param {Number} padding Percentage of padding to add to domain\n * @returns {Array} Padded Domain\n */\nfunction _padDomain(domain, padding) {\n  if (!domain) {\n    return domain;\n  }\n  if (isNaN(parseFloat(domain[0])) || isNaN(parseFloat(domain[1]))) {\n    return domain;\n  }\n\n  var _domain = _slicedToArray(domain, 2),\n      min = _domain[0],\n      max = _domain[1];\n\n  var domainPadding = (max - min) * (padding * 0.01);\n  return [min - domainPadding, max + domainPadding];\n}\n\n/**\n * Get prop functor (either a value or a function) for a given attribute.\n * @param {Object} props Series props.\n * @param {Function} accessor - Property accessor.\n * @returns {*} Function or value.\n */\nexport function getAttributeFunctor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      return scaleFn(_getAttrValue(d, scaleObject.accessor));\n    };\n  }\n  return null;\n}\n\n/**\n * Get the functor which extracts value form [attr]0 property. Use baseValue if\n * no attr0 property for a given object is defined. Fall back to domain[0] if no\n * base value is available.\n * @param {Object} props Object of props.\n * @param {string} attr Attribute name.\n * @returns {*} Function which returns value or null if no values available.\n */\nexport function getAttr0Functor(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    var domain = scaleObject.domain;\n    var _scaleObject$baseValu = scaleObject.baseValue,\n        baseValue = _scaleObject$baseValu === undefined ? domain[0] : _scaleObject$baseValu;\n\n    var scaleFn = getScaleFnFromScaleObject(scaleObject);\n    return function (d) {\n      var value = _getAttrValue(d, scaleObject.accessor0);\n      return scaleFn(_isDefined(value) ? value : baseValue);\n    };\n  }\n  return null;\n}\n\n/**\n * Tries to get the string|number value of the attr and falls back to\n * a fallback property in case if the value is a scale.\n * @param {Object} props Series props.\n * @param {string} attr Property name.\n * @returns {*} Function or value.\n */\nexport function getAttributeValue(props, attr) {\n  var scaleObject = getScaleObjectFromProps(props, attr);\n  if (scaleObject) {\n    if (!scaleObject.isValue && props['_' + attr + 'Value'] === undefined) {\n      warning('[React-vis] Cannot use data defined ' + attr + ' for this ' + 'series type. Using fallback value instead.');\n    }\n    return props['_' + attr + 'Value'] || scaleObject.range[0];\n  }\n  return null;\n}\n\n/**\n * Get prop types by the attribute.\n * @param {string} attr Attribute.\n * @returns {Object} Object of xDomain, xRange, xType, xDistance and _xValue,\n * where x is an attribute passed to the function.\n */\nexport function getScalePropTypesByAttribute(attr) {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, '_' + attr + 'Value', PropTypes.any), _defineProperty(_ref2, attr + 'Domain', PropTypes.array), _defineProperty(_ref2, 'get' + toTitleCase(attr), PropTypes.func), _defineProperty(_ref2, 'get' + toTitleCase(attr) + '0', PropTypes.func), _defineProperty(_ref2, attr + 'Range', PropTypes.array), _defineProperty(_ref2, attr + 'Type', PropTypes.oneOf(Object.keys(SCALE_FUNCTIONS))), _defineProperty(_ref2, attr + 'Distance', PropTypes.number), _defineProperty(_ref2, attr + 'BaseValue', PropTypes.any), _ref2;\n}\n\n/**\n * Extract the list of scale properties from the entire props object.\n * @param {Object} props Props.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nexport function extractScalePropsFromProps(props, attributes) {\n  var result = {};\n  Object.keys(props).forEach(function (key) {\n    // this filtering is critical for extracting the correct accessors!\n    var attr = attributes.find(function (a) {\n      // width\n      var isPlainSet = key.indexOf(a) === 0;\n      // Ex: _data\n      var isUnderscoreSet = key.indexOf('_' + a) === 0;\n      // EX: getX\n      var usesGet = key.indexOf('get' + toTitleCase(a)) === 0;\n      return isPlainSet || isUnderscoreSet || usesGet;\n    });\n    if (!attr) {\n      return;\n    }\n    result[key] = props[key];\n  });\n  return result;\n}\n\n/**\n * Extract the missing scale props from the given data and return them as\n * an object.\n * @param {Object} props Props.\n * @param {Array} data Array of all data.\n * @param {Array<String>} attributes Array of attributes for the given\n * components (for instance, `['x', 'y', 'color']`).\n * @returns {Object} Collected props.\n */\nexport function getMissingScaleProps(props, data, attributes) {\n  var result = {};\n  // Make sure that the domain is set pad it if specified\n  attributes.forEach(function (attr) {\n    if (!props['get' + toTitleCase(attr)]) {\n      result['get' + toTitleCase(attr)] = function (d) {\n        return d[attr];\n      };\n    }\n    if (!props['get' + toTitleCase(attr) + '0']) {\n      result['get' + toTitleCase(attr) + '0'] = function (d) {\n        return d[attr + '0'];\n      };\n    }\n    if (!props[attr + 'Domain']) {\n      result[attr + 'Domain'] = getDomainByAccessor(data, props['get' + toTitleCase(attr)] || result['get' + toTitleCase(attr)], props['get' + toTitleCase(attr) + '0'] || result['get' + toTitleCase(attr) + '0'], props[attr + 'Type']);\n      if (props[attr + 'Padding']) {\n        result[attr + 'Domain'] = _padDomain(result[attr + 'Domain'], props[attr + 'Padding']);\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return a d3 scale that returns the literal value that was given to it\n * @returns {function} literal scale.\n */\nexport function literalScale(defaultValue) {\n  function scale(d) {\n    if (d === undefined) {\n      return defaultValue;\n    }\n    return d;\n  }\n\n  function response() {\n    return scale;\n  }\n\n  scale.domain = response;\n  scale.range = response;\n  scale.unknown = response;\n  scale.copy = response;\n\n  return scale;\n}\n\nexport function getFontColorFromBackground(background) {\n  if (background) {\n    return hsl(background).l > 0.57 ? '#222' : '#fff';\n  }\n  return null;\n}\n\n/**\n * Creates fallback values for series from scales defined at XYPlot level.\n * @param {Object} props Props of the XYPlot object.\n * @param {Array<Object>} children Array of components, children of XYPlot\n * @returns {Array<Object>} Collected props.\n */\n\nexport function getXYPlotValues(props, children) {\n  var XYPlotScales = XYPLOT_ATTR.reduce(function (prev, attr) {\n    var domain = props[attr + 'Domain'],\n        range = props[attr + 'Range'],\n        type = props[attr + 'Type'];\n\n\n    if (domain && range && type) {\n      return _extends({}, prev, _defineProperty({}, attr, SCALE_FUNCTIONS[type]().domain(domain).range(range)));\n    }\n    return prev;\n  }, {});\n\n  return children.map(function (child) {\n    return XYPLOT_ATTR.reduce(function (prev, attr) {\n      if (child.props && child.props[attr] !== undefined) {\n        var scaleInput = child.props[attr];\n        var scale = XYPlotScales[attr];\n        var fallbackValue = scale ? scale(scaleInput) : scaleInput;\n        return _extends({}, prev, _defineProperty({}, '_' + attr + 'Value', fallbackValue));\n      }\n      return prev;\n    }, {});\n  });\n}\n\nvar OPTIONAL_SCALE_PROPS = ['Padding'];\nvar OPTIONAL_SCALE_PROPS_REGS = OPTIONAL_SCALE_PROPS.map(function (str) {\n  return new RegExp(str + '$', 'i');\n});\n/**\n * Get the list of optional scale-related settings for XYPlot\n * mostly just used to find padding properties\n * @param {Object} props Object of props.\n * @returns {Object} Optional Props.\n * @private\n */\nexport function getOptionalScaleProps(props) {\n  return Object.keys(props).reduce(function (acc, prop) {\n    var propIsNotOptional = OPTIONAL_SCALE_PROPS_REGS.every(function (reg) {\n      return !prop.match(reg);\n    });\n    if (propIsNotOptional) {\n      return acc;\n    }\n    acc[prop] = props[prop];\n    return acc;\n  }, {});\n}\n\nexport default {\n  extractScalePropsFromProps: extractScalePropsFromProps,\n  getAttributeScale: getAttributeScale,\n  getAttributeFunctor: getAttributeFunctor,\n  getAttr0Functor: getAttr0Functor,\n  getAttributeValue: getAttributeValue,\n  getDomainByAccessor: getDomainByAccessor,\n  getFontColorFromBackground: getFontColorFromBackground,\n  getMissingScaleProps: getMissingScaleProps,\n  getOptionalScaleProps: getOptionalScaleProps,\n  getScaleObjectFromProps: getScaleObjectFromProps,\n  getScalePropTypesByAttribute: getScalePropTypesByAttribute,\n  getXYPlotValues: getXYPlotValues,\n  literalScale: literalScale\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}