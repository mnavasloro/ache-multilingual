{"ast":null,"code":"// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { range } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nexport var ORIENTATION = {\n  TOP: 'top',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\nexport var DIRECTION = {\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n/**\n * Get total amount of ticks from a given size in pixels.\n * @param {number} size Size of the axis in pixels.\n * @returns {number} Total amount of ticks.\n */\n\nexport function getTicksTotalFromSize(size) {\n  if (size < 700) {\n    if (size > 300) {\n      return 10;\n    }\n\n    return 5;\n  }\n\n  return 20;\n}\n/**\n * Get the tick values from a given d3 scale.\n * @param {d3.scale} scale Scale function.\n * @param {number} tickTotal Total number of ticks\n * @param {Array} tickValues Array of tick values if they exist.\n * @returns {Array} Array of tick values.\n */\n\nexport function getTickValues(scale, tickTotal, tickValues) {\n  return !tickValues ? scale.ticks ? scale.ticks(tickTotal) : scale.domain() : tickValues;\n}\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Object describing each the line in coordinates\n */\n\nexport function generateFit(axisStart, axisEnd) {\n  // address the special case when the slope is infinite\n  if (axisStart.x === axisEnd.x) {\n    return {\n      left: axisStart.y,\n      right: axisEnd.y,\n      slope: 0,\n      offset: axisStart.x\n    };\n  }\n\n  var slope = (axisStart.y - axisEnd.y) / (axisStart.x - axisEnd.x);\n  return {\n    left: axisStart.x,\n    right: axisEnd.x,\n    // generate the linear projection of the axis direction\n    slope: slope,\n    offset: axisStart.y - slope * axisStart.x\n  };\n}\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param props\n * props.@param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Number} numberOfTicks The number of ticks on the axis\n * props.@param {Array.Numbers} axisDomain The values to be interpolated across for the axis\n * @returns {Number} Object describing the slope and the specific coordinates of the points\n */\n\nexport function generatePoints(_ref) {\n  var axisStart = _ref.axisStart,\n      axisEnd = _ref.axisEnd,\n      numberOfTicks = _ref.numberOfTicks,\n      axisDomain = _ref.axisDomain;\n\n  var _generateFit = generateFit(axisStart, axisEnd),\n      left = _generateFit.left,\n      right = _generateFit.right,\n      slope = _generateFit.slope,\n      offset = _generateFit.offset; // construct a linear band of points, then map them\n\n\n  var pointSlope = (right - left) / numberOfTicks;\n  var axisScale = scaleLinear().domain([left, right]).range(axisDomain);\n  var slopeVertical = axisStart.x === axisEnd.x;\n  return {\n    slope: slopeVertical ? Infinity : slope,\n    points: range(left, right + pointSlope, pointSlope).map(function (val) {\n      if (slopeVertical) {\n        return {\n          y: val,\n          x: slope * val + offset,\n          text: axisScale(val)\n        };\n      }\n\n      return {\n        x: val,\n        y: slope * val + offset,\n        text: axisScale(val)\n      };\n    }).slice(0, numberOfTicks + 1)\n  };\n}\n/**\n * Compute the angle (in radians) of a decorative axis\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Angle in radials\n */\n\nexport function getAxisAngle(axisStart, axisEnd) {\n  if (axisStart.x === axisEnd.x) {\n    return axisEnd.y > axisStart.y ? Math.PI / 2 : 3 * Math.PI / 2;\n  }\n\n  return Math.atan((axisEnd.y - axisStart.y) / (axisEnd.x - axisStart.x));\n}\nexport default {\n  DIRECTION: DIRECTION,\n  ORIENTATION: ORIENTATION,\n  getTicksTotalFromSize: getTicksTotalFromSize,\n  getTickValues: getTickValues\n};","map":{"version":3,"names":["range","scaleLinear","ORIENTATION","TOP","LEFT","RIGHT","BOTTOM","VERTICAL","HORIZONTAL","DIRECTION","getTicksTotalFromSize","size","getTickValues","scale","tickTotal","tickValues","ticks","domain","generateFit","axisStart","axisEnd","x","left","y","right","slope","offset","generatePoints","_ref","numberOfTicks","axisDomain","_generateFit","pointSlope","axisScale","slopeVertical","Infinity","points","map","val","text","slice","getAxisAngle","Math","PI","atan"],"sources":["C:/Users/mnavas/CODE/SmartBIC/ache-multilingual/ache-dashboard/node_modules/react-vis/es/utils/axis-utils.js"],"sourcesContent":["// Copyright (c) 2016 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { range } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\n\nexport var ORIENTATION = {\n  TOP: 'top',\n  LEFT: 'left',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n\nexport var DIRECTION = {\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n\n/**\n * Get total amount of ticks from a given size in pixels.\n * @param {number} size Size of the axis in pixels.\n * @returns {number} Total amount of ticks.\n */\nexport function getTicksTotalFromSize(size) {\n  if (size < 700) {\n    if (size > 300) {\n      return 10;\n    }\n    return 5;\n  }\n  return 20;\n}\n\n/**\n * Get the tick values from a given d3 scale.\n * @param {d3.scale} scale Scale function.\n * @param {number} tickTotal Total number of ticks\n * @param {Array} tickValues Array of tick values if they exist.\n * @returns {Array} Array of tick values.\n */\nexport function getTickValues(scale, tickTotal, tickValues) {\n  return !tickValues ? scale.ticks ? scale.ticks(tickTotal) : scale.domain() : tickValues;\n}\n\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Object describing each the line in coordinates\n */\nexport function generateFit(axisStart, axisEnd) {\n  // address the special case when the slope is infinite\n  if (axisStart.x === axisEnd.x) {\n    return {\n      left: axisStart.y,\n      right: axisEnd.y,\n      slope: 0,\n      offset: axisStart.x\n    };\n  }\n  var slope = (axisStart.y - axisEnd.y) / (axisStart.x - axisEnd.x);\n  return {\n    left: axisStart.x,\n    right: axisEnd.x,\n    // generate the linear projection of the axis direction\n    slope: slope,\n    offset: axisStart.y - slope * axisStart.x\n  };\n}\n\n/**\n * Generate a description of a decorative axis in terms of a linear equation\n * y = slope * x + offset in coordinates\n * @param props\n * props.@param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * props.@param {Number} numberOfTicks The number of ticks on the axis\n * props.@param {Array.Numbers} axisDomain The values to be interpolated across for the axis\n * @returns {Number} Object describing the slope and the specific coordinates of the points\n */\nexport function generatePoints(_ref) {\n  var axisStart = _ref.axisStart,\n      axisEnd = _ref.axisEnd,\n      numberOfTicks = _ref.numberOfTicks,\n      axisDomain = _ref.axisDomain;\n\n  var _generateFit = generateFit(axisStart, axisEnd),\n      left = _generateFit.left,\n      right = _generateFit.right,\n      slope = _generateFit.slope,\n      offset = _generateFit.offset;\n  // construct a linear band of points, then map them\n\n\n  var pointSlope = (right - left) / numberOfTicks;\n  var axisScale = scaleLinear().domain([left, right]).range(axisDomain);\n\n  var slopeVertical = axisStart.x === axisEnd.x;\n  return {\n    slope: slopeVertical ? Infinity : slope,\n    points: range(left, right + pointSlope, pointSlope).map(function (val) {\n      if (slopeVertical) {\n        return { y: val, x: slope * val + offset, text: axisScale(val) };\n      }\n      return { x: val, y: slope * val + offset, text: axisScale(val) };\n    }).slice(0, numberOfTicks + 1)\n  };\n}\n\n/**\n * Compute the angle (in radians) of a decorative axis\n * @param {Object} axisStart Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @param {Object} axisEnd Object of format {x, y} describing in coordinates\n * the start position of the decorative axis\n * @returns {Number} Angle in radials\n */\nexport function getAxisAngle(axisStart, axisEnd) {\n  if (axisStart.x === axisEnd.x) {\n    return axisEnd.y > axisStart.y ? Math.PI / 2 : 3 * Math.PI / 2;\n  }\n  return Math.atan((axisEnd.y - axisStart.y) / (axisEnd.x - axisStart.x));\n}\n\nexport default {\n  DIRECTION: DIRECTION,\n  ORIENTATION: ORIENTATION,\n  getTicksTotalFromSize: getTicksTotalFromSize,\n  getTickValues: getTickValues\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,KAAT,QAAsB,UAAtB;AACA,SAASC,WAAT,QAA4B,UAA5B;AAEA,OAAO,IAAIC,WAAW,GAAG;EACvBC,GAAG,EAAE,KADkB;EAEvBC,IAAI,EAAE,MAFiB;EAGvBC,KAAK,EAAE,OAHgB;EAIvBC,MAAM,EAAE,QAJe;EAKvBC,QAAQ,EAAE,UALa;EAMvBC,UAAU,EAAE;AANW,CAAlB;AASP,OAAO,IAAIC,SAAS,GAAG;EACrBF,QAAQ,EAAE,UADW;EAErBC,UAAU,EAAE;AAFS,CAAhB;AAKP;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,qBAAT,CAA+BC,IAA/B,EAAqC;EAC1C,IAAIA,IAAI,GAAG,GAAX,EAAgB;IACd,IAAIA,IAAI,GAAG,GAAX,EAAgB;MACd,OAAO,EAAP;IACD;;IACD,OAAO,CAAP;EACD;;EACD,OAAO,EAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,SAA9B,EAAyCC,UAAzC,EAAqD;EAC1D,OAAO,CAACA,UAAD,GAAcF,KAAK,CAACG,KAAN,GAAcH,KAAK,CAACG,KAAN,CAAYF,SAAZ,CAAd,GAAuCD,KAAK,CAACI,MAAN,EAArD,GAAsEF,UAA7E;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,WAAT,CAAqBC,SAArB,EAAgCC,OAAhC,EAAyC;EAC9C;EACA,IAAID,SAAS,CAACE,CAAV,KAAgBD,OAAO,CAACC,CAA5B,EAA+B;IAC7B,OAAO;MACLC,IAAI,EAAEH,SAAS,CAACI,CADX;MAELC,KAAK,EAAEJ,OAAO,CAACG,CAFV;MAGLE,KAAK,EAAE,CAHF;MAILC,MAAM,EAAEP,SAAS,CAACE;IAJb,CAAP;EAMD;;EACD,IAAII,KAAK,GAAG,CAACN,SAAS,CAACI,CAAV,GAAcH,OAAO,CAACG,CAAvB,KAA6BJ,SAAS,CAACE,CAAV,GAAcD,OAAO,CAACC,CAAnD,CAAZ;EACA,OAAO;IACLC,IAAI,EAAEH,SAAS,CAACE,CADX;IAELG,KAAK,EAAEJ,OAAO,CAACC,CAFV;IAGL;IACAI,KAAK,EAAEA,KAJF;IAKLC,MAAM,EAAEP,SAAS,CAACI,CAAV,GAAcE,KAAK,GAAGN,SAAS,CAACE;EALnC,CAAP;AAOD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,cAAT,CAAwBC,IAAxB,EAA8B;EACnC,IAAIT,SAAS,GAAGS,IAAI,CAACT,SAArB;EAAA,IACIC,OAAO,GAAGQ,IAAI,CAACR,OADnB;EAAA,IAEIS,aAAa,GAAGD,IAAI,CAACC,aAFzB;EAAA,IAGIC,UAAU,GAAGF,IAAI,CAACE,UAHtB;;EAKA,IAAIC,YAAY,GAAGb,WAAW,CAACC,SAAD,EAAYC,OAAZ,CAA9B;EAAA,IACIE,IAAI,GAAGS,YAAY,CAACT,IADxB;EAAA,IAEIE,KAAK,GAAGO,YAAY,CAACP,KAFzB;EAAA,IAGIC,KAAK,GAAGM,YAAY,CAACN,KAHzB;EAAA,IAIIC,MAAM,GAAGK,YAAY,CAACL,MAJ1B,CANmC,CAWnC;;;EAGA,IAAIM,UAAU,GAAG,CAACR,KAAK,GAAGF,IAAT,IAAiBO,aAAlC;EACA,IAAII,SAAS,GAAGhC,WAAW,GAAGgB,MAAd,CAAqB,CAACK,IAAD,EAAOE,KAAP,CAArB,EAAoCxB,KAApC,CAA0C8B,UAA1C,CAAhB;EAEA,IAAII,aAAa,GAAGf,SAAS,CAACE,CAAV,KAAgBD,OAAO,CAACC,CAA5C;EACA,OAAO;IACLI,KAAK,EAAES,aAAa,GAAGC,QAAH,GAAcV,KAD7B;IAELW,MAAM,EAAEpC,KAAK,CAACsB,IAAD,EAAOE,KAAK,GAAGQ,UAAf,EAA2BA,UAA3B,CAAL,CAA4CK,GAA5C,CAAgD,UAAUC,GAAV,EAAe;MACrE,IAAIJ,aAAJ,EAAmB;QACjB,OAAO;UAAEX,CAAC,EAAEe,GAAL;UAAUjB,CAAC,EAAEI,KAAK,GAAGa,GAAR,GAAcZ,MAA3B;UAAmCa,IAAI,EAAEN,SAAS,CAACK,GAAD;QAAlD,CAAP;MACD;;MACD,OAAO;QAAEjB,CAAC,EAAEiB,GAAL;QAAUf,CAAC,EAAEE,KAAK,GAAGa,GAAR,GAAcZ,MAA3B;QAAmCa,IAAI,EAAEN,SAAS,CAACK,GAAD;MAAlD,CAAP;IACD,CALO,EAKLE,KALK,CAKC,CALD,EAKIX,aAAa,GAAG,CALpB;EAFH,CAAP;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASY,YAAT,CAAsBtB,SAAtB,EAAiCC,OAAjC,EAA0C;EAC/C,IAAID,SAAS,CAACE,CAAV,KAAgBD,OAAO,CAACC,CAA5B,EAA+B;IAC7B,OAAOD,OAAO,CAACG,CAAR,GAAYJ,SAAS,CAACI,CAAtB,GAA0BmB,IAAI,CAACC,EAAL,GAAU,CAApC,GAAwC,IAAID,IAAI,CAACC,EAAT,GAAc,CAA7D;EACD;;EACD,OAAOD,IAAI,CAACE,IAAL,CAAU,CAACxB,OAAO,CAACG,CAAR,GAAYJ,SAAS,CAACI,CAAvB,KAA6BH,OAAO,CAACC,CAAR,GAAYF,SAAS,CAACE,CAAnD,CAAV,CAAP;AACD;AAED,eAAe;EACbZ,SAAS,EAAEA,SADE;EAEbP,WAAW,EAAEA,WAFA;EAGbQ,qBAAqB,EAAEA,qBAHV;EAIbE,aAAa,EAAEA;AAJF,CAAf"},"metadata":{},"sourceType":"module"}